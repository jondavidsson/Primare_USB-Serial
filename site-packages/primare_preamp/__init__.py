"""
Primare has an RS232 interface to control the preamp.

Not all preamps have all functions.
Functions can be found on in the xls file within this repository
"""

import codecs
import socket
from time import sleep
from primare_preamp.primare_commands import CMDS
import serial  # pylint: disable=import-error
import threading
import telnetlib
import logging
import time

DEFAULT_TIMEOUT = 0.5
DEFAULT_WRITE_TIMEOUT = 0.5

_LOGGER = logging.getLogger(__name__)

_LOGGER.debug("Loading Primare python package 1.0.0")

class PrimarePreamp(object):
    """Primare preamp."""

    def __init__(self, serial_port, timeout=DEFAULT_TIMEOUT,
                 write_timeout=DEFAULT_WRITE_TIMEOUT):
        """Create RS232 connection."""
        self.ser = serial.Serial(serial_port, baudrate=4800, bytesize=8, parity='N', stopbits=1, timeout=timeout,
                                 write_timeout=write_timeout)
        self.lock = threading.Lock()

    def exec_command(self, domain, function, operator, value=None):
        """
        Write a command to the preamp and read the value it returns.
        The preamp will always return a value, also when setting a value.
        """
        raw_command = CMDS[domain][function]['cmd']
        if operator in CMDS[domain][function]['supported_operators']:
            if value is None:
                raise ValueError('No value provided')
            else:
                cmd = ''.join([operator, raw_command, str(value)])

        else:
            raise ValueError('Invalid operator provided %s' % operator)
        with self.lock:
            if not self.ser.is_open:
                self.ser.open()

            self.ser.reset_input_buffer()
            self.ser.reset_output_buffer()
    
            # Primare uses the prefix @ and the suffix \r, so add those to the above cmd.
            final_command = ''.join(['\x02', cmd, '\x10\x03']).encode('latin')
            _LOGGER.debug ('Send Command %s',final_command)
    
            self.ser.write(final_command)
    
            msg = self.ser.read_until(bytes('\x10\x03'.encode()))

        _LOGGER.debug ('Response msg %s', msg)

        split_string = int.from_bytes(msg[2:3],byteorder='big') #msg.decode().strip().split('\x03')

        _LOGGER.debug("Decoded split string %s", split_string)

        return split_string
        # Check return value contains the same command value as requested. Sometimes the marantz gets out of sync. Ignore if this is the case
        # if split_string[0] != ('@' + raw_command):
        #     _LOGGER.debug ("Send & Response command values dont match %s != %s - Ignoring returned value", split_string[0], '@' + raw_command )
        #     return None
        # else:
        #      return split_string[1]
        #      # b'AMT:0\r will return 0

    def main_mute(self, operator, value=None):
        """Execute Main.Mute."""
        return self.exec_command('main', 'mute', operator, value)

    def main_power(self, operator, value=None):
        """Execute Main.Power."""
        return self.exec_command('main', 'power', operator, value)

    def main_volume(self, operator, value=None):
        """
        Execute Main.Volume.
        Returns int
        """
        vol_result = self.exec_command('main', 'volume', operator, value)
        vol_return = vol_result/100
        if vol_result != None:
            return vol_return

    def main_volume_set(self, operator, value=None):
        """
        Execute Main.Volume.
        Returns int
        """
        vol_result = self.exec_command('main', 'volume_set', operator, value)
        vol_return = int(vol_result/0.79)
        vol_return = vol_return/100
        if vol_return != None:
            return vol_return

    def main_autostatus (self, operator, value=None):
        """
        Execute autostatus.
        Not currently used but will allow two-way communications in future

        Returns int
        """
        return int(self.exec_command('main', 'autostatus', operator, value))